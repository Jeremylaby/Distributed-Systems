# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `SmartHome.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module SmartHome
_M_SmartHome = Ice.openModule('SmartHome')
__name__ = 'SmartHome'

if 'TemperatureSettings' not in _M_SmartHome.__dict__:
    _M_SmartHome.TemperatureSettings = Ice.createTempClass()
    class TemperatureSettings(object):
        def __init__(self, currTemp=0, maxTemp=0, minTemp=0):
            self.currTemp = currTemp
            self.maxTemp = maxTemp
            self.minTemp = minTemp

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.currTemp)
            _h = 5 * _h + Ice.getHash(self.maxTemp)
            _h = 5 * _h + Ice.getHash(self.minTemp)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.TemperatureSettings):
                return NotImplemented
            else:
                if self.currTemp is None or other.currTemp is None:
                    if self.currTemp != other.currTemp:
                        return (-1 if self.currTemp is None else 1)
                else:
                    if self.currTemp < other.currTemp:
                        return -1
                    elif self.currTemp > other.currTemp:
                        return 1
                if self.maxTemp is None or other.maxTemp is None:
                    if self.maxTemp != other.maxTemp:
                        return (-1 if self.maxTemp is None else 1)
                else:
                    if self.maxTemp < other.maxTemp:
                        return -1
                    elif self.maxTemp > other.maxTemp:
                        return 1
                if self.minTemp is None or other.minTemp is None:
                    if self.minTemp != other.minTemp:
                        return (-1 if self.minTemp is None else 1)
                else:
                    if self.minTemp < other.minTemp:
                        return -1
                    elif self.minTemp > other.minTemp:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_TemperatureSettings)

        __repr__ = __str__

    _M_SmartHome._t_TemperatureSettings = IcePy.defineStruct('::SmartHome::TemperatureSettings', TemperatureSettings, (), (
        ('currTemp', (), IcePy._t_int),
        ('maxTemp', (), IcePy._t_int),
        ('minTemp', (), IcePy._t_int)
    ))

    _M_SmartHome.TemperatureSettings = TemperatureSettings
    del TemperatureSettings

if 'Color' not in _M_SmartHome.__dict__:
    _M_SmartHome.Color = Ice.createTempClass()
    class Color(object):
        def __init__(self, R=0, G=0, B=0):
            self.R = R
            self.G = G
            self.B = B

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.R)
            _h = 5 * _h + Ice.getHash(self.G)
            _h = 5 * _h + Ice.getHash(self.B)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.Color):
                return NotImplemented
            else:
                if self.R is None or other.R is None:
                    if self.R != other.R:
                        return (-1 if self.R is None else 1)
                else:
                    if self.R < other.R:
                        return -1
                    elif self.R > other.R:
                        return 1
                if self.G is None or other.G is None:
                    if self.G != other.G:
                        return (-1 if self.G is None else 1)
                else:
                    if self.G < other.G:
                        return -1
                    elif self.G > other.G:
                        return 1
                if self.B is None or other.B is None:
                    if self.B != other.B:
                        return (-1 if self.B is None else 1)
                else:
                    if self.B < other.B:
                        return -1
                    elif self.B > other.B:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_Color)

        __repr__ = __str__

    _M_SmartHome._t_Color = IcePy.defineStruct('::SmartHome::Color', Color, (), (
        ('R', (), IcePy._t_int),
        ('G', (), IcePy._t_int),
        ('B', (), IcePy._t_int)
    ))

    _M_SmartHome.Color = Color
    del Color

if 'Position' not in _M_SmartHome.__dict__:
    _M_SmartHome.Position = Ice.createTempClass()
    class Position(object):
        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.x)
            _h = 5 * _h + Ice.getHash(self.y)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.Position):
                return NotImplemented
            else:
                if self.x is None or other.x is None:
                    if self.x != other.x:
                        return (-1 if self.x is None else 1)
                else:
                    if self.x < other.x:
                        return -1
                    elif self.x > other.x:
                        return 1
                if self.y is None or other.y is None:
                    if self.y != other.y:
                        return (-1 if self.y is None else 1)
                else:
                    if self.y < other.y:
                        return -1
                    elif self.y > other.y:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_Position)

        __repr__ = __str__

    _M_SmartHome._t_Position = IcePy.defineStruct('::SmartHome::Position', Position, (), (
        ('x', (), IcePy._t_int),
        ('y', (), IcePy._t_int)
    ))

    _M_SmartHome.Position = Position
    del Position

if 'ZoomLevel' not in _M_SmartHome.__dict__:
    _M_SmartHome.ZoomLevel = Ice.createTempClass()
    class ZoomLevel(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ZoomLevel.ZoomX1 = ZoomLevel("ZoomX1", 0)
    ZoomLevel.ZoomX2 = ZoomLevel("ZoomX2", 1)
    ZoomLevel.ZoomX3 = ZoomLevel("ZoomX3", 2)
    ZoomLevel.ZoomX4 = ZoomLevel("ZoomX4", 3)
    ZoomLevel.ZoomX5 = ZoomLevel("ZoomX5", 4)
    ZoomLevel._enumerators = { 0:ZoomLevel.ZoomX1, 1:ZoomLevel.ZoomX2, 2:ZoomLevel.ZoomX3, 3:ZoomLevel.ZoomX4, 4:ZoomLevel.ZoomX5 }

    _M_SmartHome._t_ZoomLevel = IcePy.defineEnum('::SmartHome::ZoomLevel', ZoomLevel, (), ZoomLevel._enumerators)

    _M_SmartHome.ZoomLevel = ZoomLevel
    del ZoomLevel

if 'CameraSettings' not in _M_SmartHome.__dict__:
    _M_SmartHome.CameraSettings = Ice.createTempClass()
    class CameraSettings(object):
        def __init__(self, minX=0, maxX=0, minY=0, maxY=0, minZoom=_M_SmartHome.ZoomLevel.ZoomX1, maxZoom=_M_SmartHome.ZoomLevel.ZoomX1):
            self.minX = minX
            self.maxX = maxX
            self.minY = minY
            self.maxY = maxY
            self.minZoom = minZoom
            self.maxZoom = maxZoom

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.minX)
            _h = 5 * _h + Ice.getHash(self.maxX)
            _h = 5 * _h + Ice.getHash(self.minY)
            _h = 5 * _h + Ice.getHash(self.maxY)
            _h = 5 * _h + Ice.getHash(self.minZoom)
            _h = 5 * _h + Ice.getHash(self.maxZoom)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.CameraSettings):
                return NotImplemented
            else:
                if self.minX is None or other.minX is None:
                    if self.minX != other.minX:
                        return (-1 if self.minX is None else 1)
                else:
                    if self.minX < other.minX:
                        return -1
                    elif self.minX > other.minX:
                        return 1
                if self.maxX is None or other.maxX is None:
                    if self.maxX != other.maxX:
                        return (-1 if self.maxX is None else 1)
                else:
                    if self.maxX < other.maxX:
                        return -1
                    elif self.maxX > other.maxX:
                        return 1
                if self.minY is None or other.minY is None:
                    if self.minY != other.minY:
                        return (-1 if self.minY is None else 1)
                else:
                    if self.minY < other.minY:
                        return -1
                    elif self.minY > other.minY:
                        return 1
                if self.maxY is None or other.maxY is None:
                    if self.maxY != other.maxY:
                        return (-1 if self.maxY is None else 1)
                else:
                    if self.maxY < other.maxY:
                        return -1
                    elif self.maxY > other.maxY:
                        return 1
                if self.minZoom is None or other.minZoom is None:
                    if self.minZoom != other.minZoom:
                        return (-1 if self.minZoom is None else 1)
                else:
                    if self.minZoom < other.minZoom:
                        return -1
                    elif self.minZoom > other.minZoom:
                        return 1
                if self.maxZoom is None or other.maxZoom is None:
                    if self.maxZoom != other.maxZoom:
                        return (-1 if self.maxZoom is None else 1)
                else:
                    if self.maxZoom < other.maxZoom:
                        return -1
                    elif self.maxZoom > other.maxZoom:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_CameraSettings)

        __repr__ = __str__

    _M_SmartHome._t_CameraSettings = IcePy.defineStruct('::SmartHome::CameraSettings', CameraSettings, (), (
        ('minX', (), IcePy._t_int),
        ('maxX', (), IcePy._t_int),
        ('minY', (), IcePy._t_int),
        ('maxY', (), IcePy._t_int),
        ('minZoom', (), _M_SmartHome._t_ZoomLevel),
        ('maxZoom', (), _M_SmartHome._t_ZoomLevel)
    ))

    _M_SmartHome.CameraSettings = CameraSettings
    del CameraSettings

if 'DeviceError' not in _M_SmartHome.__dict__:
    _M_SmartHome.DeviceError = Ice.createTempClass()
    class DeviceError(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::DeviceError'

    _M_SmartHome._t_DeviceError = IcePy.defineException('::SmartHome::DeviceError', DeviceError, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    DeviceError._ice_type = _M_SmartHome._t_DeviceError

    _M_SmartHome.DeviceError = DeviceError
    del DeviceError

if 'ConnectionError' not in _M_SmartHome.__dict__:
    _M_SmartHome.ConnectionError = Ice.createTempClass()
    class ConnectionError(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::ConnectionError'

    _M_SmartHome._t_ConnectionError = IcePy.defineException('::SmartHome::ConnectionError', ConnectionError, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    ConnectionError._ice_type = _M_SmartHome._t_ConnectionError

    _M_SmartHome.ConnectionError = ConnectionError
    del ConnectionError

if 'InvalidParameterError' not in _M_SmartHome.__dict__:
    _M_SmartHome.InvalidParameterError = Ice.createTempClass()
    class InvalidParameterError(Ice.UserException):
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::InvalidParameterError'

    _M_SmartHome._t_InvalidParameterError = IcePy.defineException('::SmartHome::InvalidParameterError', InvalidParameterError, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidParameterError._ice_type = _M_SmartHome._t_InvalidParameterError

    _M_SmartHome.InvalidParameterError = InvalidParameterError
    del InvalidParameterError

_M_SmartHome._t_Device = IcePy.defineValue('::SmartHome::Device', Ice.Value, -1, (), False, True, None, ())

if 'DevicePrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.DevicePrx = Ice.createTempClass()
    class DevicePrx(Ice.ObjectPrx):

        def turnOn(self, context=None):
            return _M_SmartHome.Device._op_turnOn.invoke(self, ((), context))

        def turnOnAsync(self, context=None):
            return _M_SmartHome.Device._op_turnOn.invokeAsync(self, ((), context))

        def begin_turnOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Device._op_turnOn.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOn(self, _r):
            return _M_SmartHome.Device._op_turnOn.end(self, _r)

        def turnOff(self, context=None):
            return _M_SmartHome.Device._op_turnOff.invoke(self, ((), context))

        def turnOffAsync(self, context=None):
            return _M_SmartHome.Device._op_turnOff.invokeAsync(self, ((), context))

        def begin_turnOff(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Device._op_turnOff.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOff(self, _r):
            return _M_SmartHome.Device._op_turnOff.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.DevicePrx.ice_checkedCast(proxy, '::SmartHome::Device', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.DevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'
    _M_SmartHome._t_DevicePrx = IcePy.defineProxy('::SmartHome::Device', DevicePrx)

    _M_SmartHome.DevicePrx = DevicePrx
    del DevicePrx

    _M_SmartHome.Device = Ice.createTempClass()
    class Device(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::Device'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'

        def turnOn(self, current=None):
            raise NotImplementedError("servant method 'turnOn' not implemented")

        def turnOff(self, current=None):
            raise NotImplementedError("servant method 'turnOff' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DeviceDisp)

        __repr__ = __str__

    _M_SmartHome._t_DeviceDisp = IcePy.defineClass('::SmartHome::Device', Device, (), None, ())
    Device._ice_type = _M_SmartHome._t_DeviceDisp

    Device._op_turnOn = IcePy.Operation('turnOn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_DeviceError, _M_SmartHome._t_ConnectionError))
    Device._op_turnOff = IcePy.Operation('turnOff', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_DeviceError, _M_SmartHome._t_ConnectionError))

    _M_SmartHome.Device = Device
    del Device

_M_SmartHome._t_Lamp = IcePy.defineValue('::SmartHome::Lamp', Ice.Value, -1, (), False, True, None, ())

if 'LampPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.LampPrx = Ice.createTempClass()
    class LampPrx(_M_SmartHome.DevicePrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.LampPrx.ice_checkedCast(proxy, '::SmartHome::Lamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.LampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Lamp'
    _M_SmartHome._t_LampPrx = IcePy.defineProxy('::SmartHome::Lamp', LampPrx)

    _M_SmartHome.LampPrx = LampPrx
    del LampPrx

    _M_SmartHome.Lamp = Ice.createTempClass()
    class Lamp(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::Lamp')

        def ice_id(self, current=None):
            return '::SmartHome::Lamp'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Lamp'

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_LampDisp)

        __repr__ = __str__

    _M_SmartHome._t_LampDisp = IcePy.defineClass('::SmartHome::Lamp', Lamp, (), None, (_M_SmartHome._t_DeviceDisp,))
    Lamp._ice_type = _M_SmartHome._t_LampDisp

    _M_SmartHome.Lamp = Lamp
    del Lamp

_M_SmartHome._t_RGBLamp = IcePy.defineValue('::SmartHome::RGBLamp', Ice.Value, -1, (), False, True, None, ())

if 'RGBLampPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.RGBLampPrx = Ice.createTempClass()
    class RGBLampPrx(_M_SmartHome.LampPrx):

        def setColor(self, color, context=None):
            return _M_SmartHome.RGBLamp._op_setColor.invoke(self, ((color, ), context))

        def setColorAsync(self, color, context=None):
            return _M_SmartHome.RGBLamp._op_setColor.invokeAsync(self, ((color, ), context))

        def begin_setColor(self, color, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.RGBLamp._op_setColor.begin(self, ((color, ), _response, _ex, _sent, context))

        def end_setColor(self, _r):
            return _M_SmartHome.RGBLamp._op_setColor.end(self, _r)

        def getColor(self, context=None):
            return _M_SmartHome.RGBLamp._op_getColor.invoke(self, ((), context))

        def getColorAsync(self, context=None):
            return _M_SmartHome.RGBLamp._op_getColor.invokeAsync(self, ((), context))

        def begin_getColor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.RGBLamp._op_getColor.begin(self, ((), _response, _ex, _sent, context))

        def end_getColor(self, _r):
            return _M_SmartHome.RGBLamp._op_getColor.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.RGBLampPrx.ice_checkedCast(proxy, '::SmartHome::RGBLamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.RGBLampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::RGBLamp'
    _M_SmartHome._t_RGBLampPrx = IcePy.defineProxy('::SmartHome::RGBLamp', RGBLampPrx)

    _M_SmartHome.RGBLampPrx = RGBLampPrx
    del RGBLampPrx

    _M_SmartHome.RGBLamp = Ice.createTempClass()
    class RGBLamp(_M_SmartHome.Lamp):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::Lamp', '::SmartHome::RGBLamp')

        def ice_id(self, current=None):
            return '::SmartHome::RGBLamp'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::RGBLamp'

        def setColor(self, color, current=None):
            raise NotImplementedError("servant method 'setColor' not implemented")

        def getColor(self, current=None):
            raise NotImplementedError("servant method 'getColor' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_RGBLampDisp)

        __repr__ = __str__

    _M_SmartHome._t_RGBLampDisp = IcePy.defineClass('::SmartHome::RGBLamp', RGBLamp, (), None, (_M_SmartHome._t_LampDisp,))
    RGBLamp._ice_type = _M_SmartHome._t_RGBLampDisp

    RGBLamp._op_setColor = IcePy.Operation('setColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Color, False, 0),), (), ((), _M_SmartHome._t_Color, False, 0), (_M_SmartHome._t_DeviceError, _M_SmartHome._t_InvalidParameterError))
    RGBLamp._op_getColor = IcePy.Operation('getColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_Color, False, 0), (_M_SmartHome._t_DeviceError,))

    _M_SmartHome.RGBLamp = RGBLamp
    del RGBLamp

_M_SmartHome._t_AirConditioning = IcePy.defineValue('::SmartHome::AirConditioning', Ice.Value, -1, (), False, True, None, ())

if 'AirConditioningPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.AirConditioningPrx = Ice.createTempClass()
    class AirConditioningPrx(_M_SmartHome.DevicePrx):

        def getTemperatureSettings(self, context=None):
            return _M_SmartHome.AirConditioning._op_getTemperatureSettings.invoke(self, ((), context))

        def getTemperatureSettingsAsync(self, context=None):
            return _M_SmartHome.AirConditioning._op_getTemperatureSettings.invokeAsync(self, ((), context))

        def begin_getTemperatureSettings(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.AirConditioning._op_getTemperatureSettings.begin(self, ((), _response, _ex, _sent, context))

        def end_getTemperatureSettings(self, _r):
            return _M_SmartHome.AirConditioning._op_getTemperatureSettings.end(self, _r)

        def setTemperature(self, temp, context=None):
            return _M_SmartHome.AirConditioning._op_setTemperature.invoke(self, ((temp, ), context))

        def setTemperatureAsync(self, temp, context=None):
            return _M_SmartHome.AirConditioning._op_setTemperature.invokeAsync(self, ((temp, ), context))

        def begin_setTemperature(self, temp, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.AirConditioning._op_setTemperature.begin(self, ((temp, ), _response, _ex, _sent, context))

        def end_setTemperature(self, _r):
            return _M_SmartHome.AirConditioning._op_setTemperature.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.AirConditioningPrx.ice_checkedCast(proxy, '::SmartHome::AirConditioning', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.AirConditioningPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AirConditioning'
    _M_SmartHome._t_AirConditioningPrx = IcePy.defineProxy('::SmartHome::AirConditioning', AirConditioningPrx)

    _M_SmartHome.AirConditioningPrx = AirConditioningPrx
    del AirConditioningPrx

    _M_SmartHome.AirConditioning = Ice.createTempClass()
    class AirConditioning(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::AirConditioning', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::AirConditioning'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AirConditioning'

        def getTemperatureSettings(self, current=None):
            raise NotImplementedError("servant method 'getTemperatureSettings' not implemented")

        def setTemperature(self, temp, current=None):
            raise NotImplementedError("servant method 'setTemperature' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_AirConditioningDisp)

        __repr__ = __str__

    _M_SmartHome._t_AirConditioningDisp = IcePy.defineClass('::SmartHome::AirConditioning', AirConditioning, (), None, (_M_SmartHome._t_DeviceDisp,))
    AirConditioning._ice_type = _M_SmartHome._t_AirConditioningDisp

    AirConditioning._op_getTemperatureSettings = IcePy.Operation('getTemperatureSettings', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_TemperatureSettings, False, 0), (_M_SmartHome._t_DeviceError,))
    AirConditioning._op_setTemperature = IcePy.Operation('setTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_SmartHome._t_DeviceError, _M_SmartHome._t_InvalidParameterError))

    _M_SmartHome.AirConditioning = AirConditioning
    del AirConditioning

_M_SmartHome._t_AirConditioningWithThermometer = IcePy.defineValue('::SmartHome::AirConditioningWithThermometer', Ice.Value, -1, (), False, True, None, ())

if 'AirConditioningWithThermometerPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.AirConditioningWithThermometerPrx = Ice.createTempClass()
    class AirConditioningWithThermometerPrx(_M_SmartHome.AirConditioningPrx):

        def getRoomTemp(self, context=None):
            return _M_SmartHome.AirConditioningWithThermometer._op_getRoomTemp.invoke(self, ((), context))

        def getRoomTempAsync(self, context=None):
            return _M_SmartHome.AirConditioningWithThermometer._op_getRoomTemp.invokeAsync(self, ((), context))

        def begin_getRoomTemp(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.AirConditioningWithThermometer._op_getRoomTemp.begin(self, ((), _response, _ex, _sent, context))

        def end_getRoomTemp(self, _r):
            return _M_SmartHome.AirConditioningWithThermometer._op_getRoomTemp.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.AirConditioningWithThermometerPrx.ice_checkedCast(proxy, '::SmartHome::AirConditioningWithThermometer', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.AirConditioningWithThermometerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AirConditioningWithThermometer'
    _M_SmartHome._t_AirConditioningWithThermometerPrx = IcePy.defineProxy('::SmartHome::AirConditioningWithThermometer', AirConditioningWithThermometerPrx)

    _M_SmartHome.AirConditioningWithThermometerPrx = AirConditioningWithThermometerPrx
    del AirConditioningWithThermometerPrx

    _M_SmartHome.AirConditioningWithThermometer = Ice.createTempClass()
    class AirConditioningWithThermometer(_M_SmartHome.AirConditioning):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::AirConditioning', '::SmartHome::AirConditioningWithThermometer', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::AirConditioningWithThermometer'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AirConditioningWithThermometer'

        def getRoomTemp(self, current=None):
            raise NotImplementedError("servant method 'getRoomTemp' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_AirConditioningWithThermometerDisp)

        __repr__ = __str__

    _M_SmartHome._t_AirConditioningWithThermometerDisp = IcePy.defineClass('::SmartHome::AirConditioningWithThermometer', AirConditioningWithThermometer, (), None, (_M_SmartHome._t_AirConditioningDisp,))
    AirConditioningWithThermometer._ice_type = _M_SmartHome._t_AirConditioningWithThermometerDisp

    AirConditioningWithThermometer._op_getRoomTemp = IcePy.Operation('getRoomTemp', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_SmartHome._t_DeviceError,))

    _M_SmartHome.AirConditioningWithThermometer = AirConditioningWithThermometer
    del AirConditioningWithThermometer

_M_SmartHome._t_Camera = IcePy.defineValue('::SmartHome::Camera', Ice.Value, -1, (), False, True, None, ())

if 'CameraPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.CameraPrx = Ice.createTempClass()
    class CameraPrx(_M_SmartHome.DevicePrx):

        def move(self, pos, context=None):
            return _M_SmartHome.Camera._op_move.invoke(self, ((pos, ), context))

        def moveAsync(self, pos, context=None):
            return _M_SmartHome.Camera._op_move.invokeAsync(self, ((pos, ), context))

        def begin_move(self, pos, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Camera._op_move.begin(self, ((pos, ), _response, _ex, _sent, context))

        def end_move(self, _r):
            return _M_SmartHome.Camera._op_move.end(self, _r)

        def getPosition(self, context=None):
            return _M_SmartHome.Camera._op_getPosition.invoke(self, ((), context))

        def getPositionAsync(self, context=None):
            return _M_SmartHome.Camera._op_getPosition.invokeAsync(self, ((), context))

        def begin_getPosition(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Camera._op_getPosition.begin(self, ((), _response, _ex, _sent, context))

        def end_getPosition(self, _r):
            return _M_SmartHome.Camera._op_getPosition.end(self, _r)

        def setZoom(self, zoom, context=None):
            return _M_SmartHome.Camera._op_setZoom.invoke(self, ((zoom, ), context))

        def setZoomAsync(self, zoom, context=None):
            return _M_SmartHome.Camera._op_setZoom.invokeAsync(self, ((zoom, ), context))

        def begin_setZoom(self, zoom, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Camera._op_setZoom.begin(self, ((zoom, ), _response, _ex, _sent, context))

        def end_setZoom(self, _r):
            return _M_SmartHome.Camera._op_setZoom.end(self, _r)

        def getZoom(self, context=None):
            return _M_SmartHome.Camera._op_getZoom.invoke(self, ((), context))

        def getZoomAsync(self, context=None):
            return _M_SmartHome.Camera._op_getZoom.invokeAsync(self, ((), context))

        def begin_getZoom(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Camera._op_getZoom.begin(self, ((), _response, _ex, _sent, context))

        def end_getZoom(self, _r):
            return _M_SmartHome.Camera._op_getZoom.end(self, _r)

        def getCameraSettings(self, context=None):
            return _M_SmartHome.Camera._op_getCameraSettings.invoke(self, ((), context))

        def getCameraSettingsAsync(self, context=None):
            return _M_SmartHome.Camera._op_getCameraSettings.invokeAsync(self, ((), context))

        def begin_getCameraSettings(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Camera._op_getCameraSettings.begin(self, ((), _response, _ex, _sent, context))

        def end_getCameraSettings(self, _r):
            return _M_SmartHome.Camera._op_getCameraSettings.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.CameraPrx.ice_checkedCast(proxy, '::SmartHome::Camera', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.CameraPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Camera'
    _M_SmartHome._t_CameraPrx = IcePy.defineProxy('::SmartHome::Camera', CameraPrx)

    _M_SmartHome.CameraPrx = CameraPrx
    del CameraPrx

    _M_SmartHome.Camera = Ice.createTempClass()
    class Camera(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Camera', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::Camera'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Camera'

        def move(self, pos, current=None):
            raise NotImplementedError("servant method 'move' not implemented")

        def getPosition(self, current=None):
            raise NotImplementedError("servant method 'getPosition' not implemented")

        def setZoom(self, zoom, current=None):
            raise NotImplementedError("servant method 'setZoom' not implemented")

        def getZoom(self, current=None):
            raise NotImplementedError("servant method 'getZoom' not implemented")

        def getCameraSettings(self, current=None):
            raise NotImplementedError("servant method 'getCameraSettings' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_CameraDisp)

        __repr__ = __str__

    _M_SmartHome._t_CameraDisp = IcePy.defineClass('::SmartHome::Camera', Camera, (), None, (_M_SmartHome._t_DeviceDisp,))
    Camera._ice_type = _M_SmartHome._t_CameraDisp

    Camera._op_move = IcePy.Operation('move', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Position, False, 0),), (), None, (_M_SmartHome._t_DeviceError, _M_SmartHome._t_InvalidParameterError))
    Camera._op_getPosition = IcePy.Operation('getPosition', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_Position, False, 0), (_M_SmartHome._t_DeviceError,))
    Camera._op_setZoom = IcePy.Operation('setZoom', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_ZoomLevel, False, 0),), (), None, (_M_SmartHome._t_DeviceError, _M_SmartHome._t_InvalidParameterError))
    Camera._op_getZoom = IcePy.Operation('getZoom', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_ZoomLevel, False, 0), (_M_SmartHome._t_DeviceError,))
    Camera._op_getCameraSettings = IcePy.Operation('getCameraSettings', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_CameraSettings, False, 0), (_M_SmartHome._t_DeviceError,))

    _M_SmartHome.Camera = Camera
    del Camera

_M_SmartHome._t_NVCamera = IcePy.defineValue('::SmartHome::NVCamera', Ice.Value, -1, (), False, True, None, ())

if 'NVCameraPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.NVCameraPrx = Ice.createTempClass()
    class NVCameraPrx(_M_SmartHome.CameraPrx):

        def enableNightVision(self, context=None):
            return _M_SmartHome.NVCamera._op_enableNightVision.invoke(self, ((), context))

        def enableNightVisionAsync(self, context=None):
            return _M_SmartHome.NVCamera._op_enableNightVision.invokeAsync(self, ((), context))

        def begin_enableNightVision(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.NVCamera._op_enableNightVision.begin(self, ((), _response, _ex, _sent, context))

        def end_enableNightVision(self, _r):
            return _M_SmartHome.NVCamera._op_enableNightVision.end(self, _r)

        def disableNightVision(self, context=None):
            return _M_SmartHome.NVCamera._op_disableNightVision.invoke(self, ((), context))

        def disableNightVisionAsync(self, context=None):
            return _M_SmartHome.NVCamera._op_disableNightVision.invokeAsync(self, ((), context))

        def begin_disableNightVision(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.NVCamera._op_disableNightVision.begin(self, ((), _response, _ex, _sent, context))

        def end_disableNightVision(self, _r):
            return _M_SmartHome.NVCamera._op_disableNightVision.end(self, _r)

        def isNightVisionEnabled(self, context=None):
            return _M_SmartHome.NVCamera._op_isNightVisionEnabled.invoke(self, ((), context))

        def isNightVisionEnabledAsync(self, context=None):
            return _M_SmartHome.NVCamera._op_isNightVisionEnabled.invokeAsync(self, ((), context))

        def begin_isNightVisionEnabled(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.NVCamera._op_isNightVisionEnabled.begin(self, ((), _response, _ex, _sent, context))

        def end_isNightVisionEnabled(self, _r):
            return _M_SmartHome.NVCamera._op_isNightVisionEnabled.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.NVCameraPrx.ice_checkedCast(proxy, '::SmartHome::NVCamera', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.NVCameraPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::NVCamera'
    _M_SmartHome._t_NVCameraPrx = IcePy.defineProxy('::SmartHome::NVCamera', NVCameraPrx)

    _M_SmartHome.NVCameraPrx = NVCameraPrx
    del NVCameraPrx

    _M_SmartHome.NVCamera = Ice.createTempClass()
    class NVCamera(_M_SmartHome.Camera):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Camera', '::SmartHome::Device', '::SmartHome::NVCamera')

        def ice_id(self, current=None):
            return '::SmartHome::NVCamera'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::NVCamera'

        def enableNightVision(self, current=None):
            raise NotImplementedError("servant method 'enableNightVision' not implemented")

        def disableNightVision(self, current=None):
            raise NotImplementedError("servant method 'disableNightVision' not implemented")

        def isNightVisionEnabled(self, current=None):
            raise NotImplementedError("servant method 'isNightVisionEnabled' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_NVCameraDisp)

        __repr__ = __str__

    _M_SmartHome._t_NVCameraDisp = IcePy.defineClass('::SmartHome::NVCamera', NVCamera, (), None, (_M_SmartHome._t_CameraDisp,))
    NVCamera._ice_type = _M_SmartHome._t_NVCameraDisp

    NVCamera._op_enableNightVision = IcePy.Operation('enableNightVision', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_DeviceError,))
    NVCamera._op_disableNightVision = IcePy.Operation('disableNightVision', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_DeviceError,))
    NVCamera._op_isNightVisionEnabled = IcePy.Operation('isNightVisionEnabled', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_SmartHome._t_DeviceError,))

    _M_SmartHome.NVCamera = NVCamera
    del NVCamera

if '_t_StringSeq' not in _M_SmartHome.__dict__:
    _M_SmartHome._t_StringSeq = IcePy.defineSequence('::SmartHome::StringSeq', (), IcePy._t_string)

_M_SmartHome._t_DeviceManager = IcePy.defineValue('::SmartHome::DeviceManager', Ice.Value, -1, (), False, True, None, ())

if 'DeviceManagerPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.DeviceManagerPrx = Ice.createTempClass()
    class DeviceManagerPrx(Ice.ObjectPrx):

        def listDevices(self, context=None):
            return _M_SmartHome.DeviceManager._op_listDevices.invoke(self, ((), context))

        def listDevicesAsync(self, context=None):
            return _M_SmartHome.DeviceManager._op_listDevices.invokeAsync(self, ((), context))

        def begin_listDevices(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.DeviceManager._op_listDevices.begin(self, ((), _response, _ex, _sent, context))

        def end_listDevices(self, _r):
            return _M_SmartHome.DeviceManager._op_listDevices.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.DeviceManagerPrx.ice_checkedCast(proxy, '::SmartHome::DeviceManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.DeviceManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::DeviceManager'
    _M_SmartHome._t_DeviceManagerPrx = IcePy.defineProxy('::SmartHome::DeviceManager', DeviceManagerPrx)

    _M_SmartHome.DeviceManagerPrx = DeviceManagerPrx
    del DeviceManagerPrx

    _M_SmartHome.DeviceManager = Ice.createTempClass()
    class DeviceManager(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::DeviceManager')

        def ice_id(self, current=None):
            return '::SmartHome::DeviceManager'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::DeviceManager'

        def listDevices(self, current=None):
            raise NotImplementedError("servant method 'listDevices' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DeviceManagerDisp)

        __repr__ = __str__

    _M_SmartHome._t_DeviceManagerDisp = IcePy.defineClass('::SmartHome::DeviceManager', DeviceManager, (), None, ())
    DeviceManager._ice_type = _M_SmartHome._t_DeviceManagerDisp

    DeviceManager._op_listDevices = IcePy.Operation('listDevices', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_StringSeq, False, 0), ())

    _M_SmartHome.DeviceManager = DeviceManager
    del DeviceManager

# End of module SmartHome
